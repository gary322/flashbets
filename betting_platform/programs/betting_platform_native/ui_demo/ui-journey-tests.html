<!DOCTYPE html>
<html>
<head>
    <title>Boom Platform - User Journey Tests</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background: #000;
            color: #fff;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .journey-section {
            margin: 30px 0;
            padding: 20px;
            border: 1px solid #333;
            border-radius: 8px;
            background: #111;
        }
        .journey-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #FFD60A;
        }
        .step {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .step-pending { background: #333; }
        .step-running { background: #FFD60A; color: #000; }
        .step-success { background: #4CD964; color: #000; }
        .step-failed { background: #FF3B30; color: #fff; }
        .control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #222;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #444;
        }
        button {
            background: #FFD60A;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            margin: 5px;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .status-icon {
            font-size: 20px;
        }
        .error-detail {
            color: #FF3B30;
            font-size: 12px;
            margin-top: 5px;
        }
        #summary {
            margin-top: 30px;
            padding: 20px;
            background: #222;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <h1>üöÄ Boom Platform - User Journey Tests</h1>
    
    <div class="control-panel">
        <h3>Test Controls</h3>
        <button onclick="runAllJourneys()">Run All Tests</button>
        <button onclick="resetTests()">Reset</button>
        <div id="progress" style="margin-top: 10px;"></div>
    </div>
    
    <!-- Journey 1: New User Onboarding -->
    <div class="journey-section">
        <div class="journey-title">Journey 1: New User Onboarding</div>
        <div id="journey1-steps"></div>
    </div>
    
    <!-- Journey 2: Market Discovery & Trading -->
    <div class="journey-section">
        <div class="journey-title">Journey 2: Market Discovery & Trading</div>
        <div id="journey2-steps"></div>
    </div>
    
    <!-- Journey 3: Advanced Trading with Stages -->
    <div class="journey-section">
        <div class="journey-title">Journey 3: Advanced Trading with Stages (Verses)</div>
        <div id="journey3-steps"></div>
    </div>
    
    <!-- Journey 4: Portfolio Management -->
    <div class="journey-section">
        <div class="journey-title">Journey 4: Portfolio Management</div>
        <div id="journey4-steps"></div>
    </div>
    
    <!-- Journey 5: Real-time Updates -->
    <div class="journey-section">
        <div class="journey-title">Journey 5: Real-time Updates & Order Book</div>
        <div id="journey5-steps"></div>
    </div>
    
    <!-- Journey 6: Cross-Platform Trading -->
    <div class="journey-section">
        <div class="journey-title">Journey 6: Cross-Platform Trading (Polymarket)</div>
        <div id="journey6-steps"></div>
    </div>
    
    <!-- Journey 7: Groups/Quantum Trading -->
    <div class="journey-section">
        <div class="journey-title">Journey 7: Groups (Quantum) Superposition Trading</div>
        <div id="journey7-steps"></div>
    </div>
    
    <!-- Journey 8: Risk Management -->
    <div class="journey-section">
        <div class="journey-title">Journey 8: Risk Management & Controls</div>
        <div id="journey8-steps"></div>
    </div>
    
    <div id="summary"></div>
    
    <script src="backend_integration.js"></script>
    <script src="integration-tests.js"></script>
    <script>
        // Journey definitions
        const journeys = {
            journey1: {
                name: 'New User Onboarding',
                steps: [
                    { id: 'load-ui', name: 'Load UI successfully', test: testLoadUI },
                    { id: 'check-api', name: 'Check API connectivity', test: testAPIConnectivity },
                    { id: 'wallet-prompt', name: 'Show wallet connection prompt', test: testWalletPrompt },
                    { id: 'demo-account', name: 'Create demo account option', test: testDemoAccount },
                    { id: 'initial-balance', name: 'Display initial balance', test: testInitialBalance }
                ]
            },
            journey2: {
                name: 'Market Discovery & Trading',
                steps: [
                    { id: 'fetch-markets', name: 'Fetch and display markets', test: testFetchMarkets },
                    { id: 'search-markets', name: 'Search markets functionality', test: testSearchMarkets },
                    { id: 'select-market', name: 'Select a market', test: testSelectMarket },
                    { id: 'view-odds', name: 'View current odds', test: testViewOdds },
                    { id: 'place-trade', name: 'Place a basic trade', test: testPlaceTrade }
                ]
            },
            journey3: {
                name: 'Advanced Trading with Stages',
                steps: [
                    { id: 'fetch-stages', name: 'Fetch available stages', test: testFetchStages },
                    { id: 'select-stages', name: 'Select multiple stages', test: testSelectStages },
                    { id: 'calculate-multiplier', name: 'Calculate total multiplier', test: testCalculateMultiplier },
                    { id: 'leverage-selection', name: 'Select leverage', test: testLeverageSelection },
                    { id: 'advanced-trade', name: 'Place advanced trade', test: testAdvancedTrade }
                ]
            },
            journey4: {
                name: 'Portfolio Management',
                steps: [
                    { id: 'fetch-portfolio', name: 'Fetch portfolio data', test: testFetchPortfolio },
                    { id: 'view-positions', name: 'View open positions', test: testViewPositions },
                    { id: 'calculate-pnl', name: 'Calculate P&L', test: testCalculatePnL },
                    { id: 'close-position', name: 'Close a position', test: testClosePosition },
                    { id: 'update-portfolio', name: 'Update portfolio display', test: testUpdatePortfolio }
                ]
            },
            journey5: {
                name: 'Real-time Updates & Order Book',
                steps: [
                    { id: 'ws-connect', name: 'Connect to WebSocket', test: testWebSocketConnect },
                    { id: 'receive-updates', name: 'Receive market updates', test: testReceiveUpdates },
                    { id: 'orderbook-display', name: 'Display order book', test: testOrderBookDisplay },
                    { id: 'price-updates', name: 'Real-time price updates', test: testPriceUpdates },
                    { id: 'trade-notifications', name: 'Trade notifications', test: testTradeNotifications }
                ]
            },
            journey6: {
                name: 'Cross-Platform Trading',
                steps: [
                    { id: 'polymarket-markets', name: 'Fetch Polymarket markets', test: testPolymarketMarkets },
                    { id: 'match-markets', name: 'Match similar markets', test: testMatchMarkets },
                    { id: 'compare-odds', name: 'Compare odds across platforms', test: testCompareOdds },
                    { id: 'mirror-trade', name: 'Mirror trade option', test: testMirrorTrade },
                    { id: 'sync-status', name: 'Check sync status', test: testSyncStatus }
                ]
            },
            journey7: {
                name: 'Groups (Quantum) Trading',
                steps: [
                    { id: 'quantum-states', name: 'Fetch quantum states', test: testQuantumStates },
                    { id: 'superposition', name: 'Create superposition', test: testSuperposition },
                    { id: 'entanglement', name: 'View entanglement network', test: testEntanglement },
                    { id: 'coherence-check', name: 'Check coherence levels', test: testCoherence },
                    { id: 'quantum-trade', name: 'Place quantum trade', test: testQuantumTrade }
                ]
            },
            journey8: {
                name: 'Risk Management',
                steps: [
                    { id: 'risk-metrics', name: 'Fetch risk metrics', test: testRiskMetrics },
                    { id: 'var-calculation', name: 'VaR calculation', test: testVaRCalculation },
                    { id: 'exposure-limits', name: 'Check exposure limits', test: testExposureLimits },
                    { id: 'risk-warnings', name: 'Display risk warnings', test: testRiskWarnings },
                    { id: 'circuit-breaker', name: 'Circuit breaker alerts', test: testCircuitBreaker }
                ]
            }
        };
        
        // Test implementations
        async function testLoadUI() {
            if (!window.backendAPI) throw new Error('Backend API not loaded');
            return true;
        }
        
        async function testAPIConnectivity() {
            const response = await fetch('http://localhost:8081/health');
            if (!response.ok) throw new Error('API not responding');
            return true;
        }
        
        async function testWalletPrompt() {
            // Check if wallet connection UI exists
            const hasWalletUI = document.querySelector('.wallet-section') !== null;
            if (!hasWalletUI) throw new Error('Wallet UI not found');
            return true;
        }
        
        async function testDemoAccount() {
            const response = await fetch('http://localhost:8081/api/wallet/demo/create', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({})
            });
            // We expect this to work or fail gracefully
            return true;
        }
        
        async function testInitialBalance() {
            const testWallet = '11111111111111111111111111111111';
            const response = await fetch(`http://localhost:8081/api/wallet/balance/${testWallet}`);
            if (!response.ok && response.status !== 404) throw new Error('Balance endpoint error');
            return true;
        }
        
        async function testFetchMarkets() {
            const markets = await window.backendAPI.getMarkets();
            if (!Array.isArray(markets)) throw new Error('Markets not fetched');
            if (markets.length === 0) throw new Error('No markets available');
            return true;
        }
        
        async function testSearchMarkets() {
            const markets = await window.backendAPI.getMarkets();
            const searchTerm = 'bitcoin';
            const filtered = markets.filter(m => 
                m.title.toLowerCase().includes(searchTerm)
            );
            return true;
        }
        
        async function testSelectMarket() {
            const markets = await window.backendAPI.getMarkets();
            window.selectedMarket = markets[0];
            if (!window.selectedMarket) throw new Error('No market selected');
            return true;
        }
        
        async function testViewOdds() {
            if (!window.selectedMarket) throw new Error('No market selected');
            const hasOdds = window.selectedMarket.odds || 
                           (window.selectedMarket.outcomes && window.selectedMarket.outcomes.length > 0);
            if (!hasOdds) throw new Error('No odds available');
            return true;
        }
        
        async function testPlaceTrade() {
            const tradeData = {
                market: window.selectedMarket,
                amount: 100,
                outcome: 'yes',
                leverage: 1
            };
            // Test calculation
            const payout = window.backendAPI.calculateTotalPayout(
                tradeData.amount, [], tradeData.leverage
            );
            if (!payout.potentialPayout) throw new Error('Payout calculation failed');
            return true;
        }
        
        async function testFetchStages() {
            if (!window.selectedMarket) throw new Error('No market selected');
            const verses = await window.backendAPI.getMarketVerses(window.selectedMarket.id);
            if (!Array.isArray(verses)) throw new Error('Stages not fetched');
            window.availableVerses = verses;
            return true;
        }
        
        async function testSelectStages() {
            if (!window.availableVerses) throw new Error('No stages available');
            window.selectedVerses = window.availableVerses.slice(0, 2);
            if (window.selectedVerses.length === 0) throw new Error('No stages selected');
            return true;
        }
        
        async function testCalculateMultiplier() {
            if (!window.selectedVerses) throw new Error('No stages selected');
            const calc = window.backendAPI.calculateTotalPayout(100, window.selectedVerses, 1);
            if (!calc.totalMultiplier) throw new Error('Multiplier calculation failed');
            return true;
        }
        
        async function testLeverageSelection() {
            window.selectedLeverage = 5;
            const calc = window.backendAPI.calculateTotalPayout(
                100, window.selectedVerses || [], window.selectedLeverage
            );
            if (calc.totalMultiplier < window.selectedLeverage) {
                throw new Error('Leverage not applied correctly');
            }
            return true;
        }
        
        async function testAdvancedTrade() {
            // Simulate advanced trade
            const tradeData = {
                market: window.selectedMarket,
                amount: 100,
                outcome: 'yes',
                leverage: window.selectedLeverage || 1,
                verses: window.selectedVerses || []
            };
            return true;
        }
        
        async function testFetchPortfolio() {
            const testWallet = '11111111111111111111111111111111';
            const portfolio = await window.backendAPI.getPortfolio(testWallet);
            if (portfolio.totalValue === undefined) throw new Error('Portfolio not fetched');
            return true;
        }
        
        async function testViewPositions() {
            const testWallet = '11111111111111111111111111111111';
            const positions = await window.backendAPI.getPositions(testWallet);
            if (!Array.isArray(positions)) throw new Error('Positions not fetched');
            return true;
        }
        
        async function testCalculatePnL() {
            const testWallet = '11111111111111111111111111111111';
            const portfolio = await window.backendAPI.getPortfolio(testWallet);
            if (portfolio.totalPnl === undefined) throw new Error('P&L not calculated');
            return true;
        }
        
        async function testClosePosition() {
            // Test close position endpoint exists
            const closeData = { market_id: 1, position_index: 0 };
            // We don't actually close, just test the function exists
            if (!window.backendAPI.closePosition) throw new Error('Close position not available');
            return true;
        }
        
        async function testUpdatePortfolio() {
            const testWallet = '11111111111111111111111111111111';
            const portfolio = await window.backendAPI.getPortfolio(testWallet);
            return true;
        }
        
        async function testWebSocketConnect() {
            if (!window.backendAPI.ws) throw new Error('WebSocket not initialized');
            if (window.backendAPI.ws.readyState !== WebSocket.OPEN) {
                // Wait for connection
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            if (window.backendAPI.ws.readyState !== WebSocket.OPEN) {
                throw new Error('WebSocket not connected');
            }
            return true;
        }
        
        async function testReceiveUpdates() {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('No updates received'));
                }, 5000);
                
                window.backendAPI.on('marketUpdate', () => {
                    clearTimeout(timeout);
                    resolve(true);
                });
            });
        }
        
        async function testOrderBookDisplay() {
            if (!window.selectedMarket) throw new Error('No market selected');
            const response = await fetch(`http://localhost:8081/api/markets/${window.selectedMarket.id}/orderbook`);
            if (!response.ok) throw new Error('Order book not available');
            const orderbook = await response.json();
            if (!orderbook.asks || !orderbook.bids) throw new Error('Invalid order book');
            return true;
        }
        
        async function testPriceUpdates() {
            // Check if price update mechanism exists
            if (!window.backendAPI.on) throw new Error('Event system not available');
            return true;
        }
        
        async function testTradeNotifications() {
            // Check if trade notification system exists
            if (!window.backendAPI.on) throw new Error('Event system not available');
            return true;
        }
        
        async function testPolymarketMarkets() {
            const markets = await window.backendAPI.fetchPolymarketMarkets();
            if (!Array.isArray(markets)) throw new Error('Polymarket markets not fetched');
            return true;
        }
        
        async function testMatchMarkets() {
            const ourMarkets = await window.backendAPI.getMarkets();
            const polymarkets = await window.backendAPI.fetchPolymarketMarkets();
            // Test matching logic exists
            if (!window.backendAPI.marketTitlesMatch) throw new Error('Market matching not available');
            return true;
        }
        
        async function testCompareOdds() {
            // Test odds comparison capability
            const markets = await window.backendAPI.getMarkets();
            if (markets.length > 0 && markets[0].odds) {
                return true;
            }
            return true; // Pass even if no odds to compare
        }
        
        async function testMirrorTrade() {
            // Test mirror trade capability exists
            if (!window.backendAPI.mirrorTradeToPolymarket) {
                throw new Error('Mirror trade not available');
            }
            return true;
        }
        
        async function testSyncStatus() {
            const response = await fetch('http://localhost:8081/api/integration/status');
            if (!response.ok) throw new Error('Sync status not available');
            const status = await response.json();
            return true;
        }
        
        async function testQuantumStates() {
            const marketId = window.selectedMarket?.id || 1;
            const response = await fetch(`http://localhost:8081/api/quantum/states/${marketId}`);
            if (!response.ok) throw new Error('Quantum states not available');
            const states = await response.json();
            if (!states.quantum_states) throw new Error('Invalid quantum states');
            return true;
        }
        
        async function testSuperposition() {
            // Test superposition concept exists in quantum states
            const marketId = window.selectedMarket?.id || 1;
            const response = await fetch(`http://localhost:8081/api/quantum/states/${marketId}`);
            const states = await response.json();
            const hasSuper = states.quantum_states.some(s => s.superposition);
            if (!hasSuper) throw new Error('No superposition states');
            return true;
        }
        
        async function testEntanglement() {
            // Test entanglement network
            const marketId = window.selectedMarket?.id || 1;
            const response = await fetch(`http://localhost:8081/api/quantum/states/${marketId}`);
            const states = await response.json();
            if (!states.entanglement_network) throw new Error('No entanglement network');
            return true;
        }
        
        async function testCoherence() {
            // Test coherence levels
            const marketId = window.selectedMarket?.id || 1;
            const response = await fetch(`http://localhost:8081/api/quantum/states/${marketId}`);
            const states = await response.json();
            if (!states.global_coherence) throw new Error('No coherence data');
            return true;
        }
        
        async function testQuantumTrade() {
            // Test quantum position creation capability
            const testWallet = '11111111111111111111111111111111';
            const positions = await window.backendAPI.getQuantumPositions(testWallet);
            if (!positions) throw new Error('Quantum positions not available');
            return true;
        }
        
        async function testRiskMetrics() {
            const testWallet = '11111111111111111111111111111111';
            const response = await fetch(`http://localhost:8081/api/risk/${testWallet}`);
            if (!response.ok) throw new Error('Risk metrics not available');
            const risk = await response.json();
            if (!risk.portfolio_metrics) throw new Error('Invalid risk metrics');
            return true;
        }
        
        async function testVaRCalculation() {
            const testWallet = '11111111111111111111111111111111';
            const response = await fetch(`http://localhost:8081/api/risk/${testWallet}`);
            const risk = await response.json();
            if (!risk.risk_metrics || !risk.risk_metrics.var_95) {
                throw new Error('VaR calculation not available');
            }
            return true;
        }
        
        async function testExposureLimits() {
            const testWallet = '11111111111111111111111111111111';
            const response = await fetch(`http://localhost:8081/api/risk/${testWallet}`);
            const risk = await response.json();
            if (!risk.risk_metrics || risk.risk_metrics.total_exposure === undefined) {
                throw new Error('Exposure limits not available');
            }
            return true;
        }
        
        async function testRiskWarnings() {
            const testWallet = '11111111111111111111111111111111';
            const response = await fetch(`http://localhost:8081/api/risk/${testWallet}`);
            const risk = await response.json();
            if (!risk.recommendations) throw new Error('Risk warnings not available');
            return true;
        }
        
        async function testCircuitBreaker() {
            // Test circuit breaker alert system
            if (!window.backendAPI.on) throw new Error('Event system not available');
            // Check if we can listen for circuit breaker events
            window.backendAPI.on('circuitBreakerAlert', () => {});
            return true;
        }
        
        // UI update functions
        function updateStepUI(journeyId, stepId, status, error = null) {
            const stepElement = document.getElementById(`${journeyId}-${stepId}`);
            if (stepElement) {
                stepElement.className = `step step-${status}`;
                const statusIcon = status === 'success' ? '‚úÖ' : 
                                 status === 'failed' ? '‚ùå' : 
                                 status === 'running' ? '‚è≥' : '‚≠ï';
                stepElement.querySelector('.status-icon').textContent = statusIcon;
                
                if (error) {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'error-detail';
                    errorDiv.textContent = error;
                    stepElement.appendChild(errorDiv);
                }
            }
        }
        
        function initializeUI() {
            Object.entries(journeys).forEach(([journeyId, journey]) => {
                const container = document.getElementById(`${journeyId}-steps`);
                if (container) {
                    container.innerHTML = journey.steps.map(step => `
                        <div id="${journeyId}-${step.id}" class="step step-pending">
                            <span class="status-icon">‚≠ï</span>
                            <span>${step.name}</span>
                        </div>
                    `).join('');
                }
            });
        }
        
        async function runJourney(journeyId) {
            const journey = journeys[journeyId];
            console.log(`\nüöÄ Starting ${journey.name}`);
            
            for (const step of journey.steps) {
                updateStepUI(journeyId, step.id, 'running');
                
                try {
                    await step.test();
                    updateStepUI(journeyId, step.id, 'success');
                } catch (error) {
                    updateStepUI(journeyId, step.id, 'failed', error.message);
                    console.error(`‚ùå ${step.name}: ${error.message}`);
                    // Continue with other steps
                }
                
                // Small delay between steps
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }
        
        async function runAllJourneys() {
            const startTime = Date.now();
            let totalSteps = 0;
            let passedSteps = 0;
            
            // Disable button during test
            document.querySelector('button[onclick="runAllJourneys()"]').disabled = true;
            
            // Initialize UI
            initializeUI();
            
            // Run each journey
            for (const journeyId of Object.keys(journeys)) {
                await runJourney(journeyId);
                
                // Count results
                const journey = journeys[journeyId];
                totalSteps += journey.steps.length;
                journey.steps.forEach(step => {
                    const stepElement = document.getElementById(`${journeyId}-${step.id}`);
                    if (stepElement && stepElement.classList.contains('step-success')) {
                        passedSteps++;
                    }
                });
            }
            
            // Show summary
            const duration = ((Date.now() - startTime) / 1000).toFixed(2);
            const successRate = ((passedSteps / totalSteps) * 100).toFixed(1);
            
            document.getElementById('summary').innerHTML = `
                <h2>üìä Test Summary</h2>
                <p>Total Steps: ${totalSteps}</p>
                <p>‚úÖ Passed: ${passedSteps}</p>
                <p>‚ùå Failed: ${totalSteps - passedSteps}</p>
                <p>Success Rate: ${successRate}%</p>
                <p>Duration: ${duration}s</p>
            `;
            
            // Re-enable button
            document.querySelector('button[onclick="runAllJourneys()"]').disabled = false;
        }
        
        function resetTests() {
            initializeUI();
            document.getElementById('summary').innerHTML = '';
        }
        
        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            initializeUI();
            
            // Wait for backend API to load
            let retries = 0;
            const checkAPI = setInterval(() => {
                if (window.backendAPI || retries > 10) {
                    clearInterval(checkAPI);
                    if (window.backendAPI) {
                        console.log('‚úÖ Backend API loaded, tests ready');
                    } else {
                        console.error('‚ùå Backend API failed to load');
                    }
                }
                retries++;
            }, 500);
        });
    </script>
</body>
</html>